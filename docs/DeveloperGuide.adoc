= DIYeats - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toclevels: 2
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:warning-caption: :warning:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2113T-W13-4/main

By: `Team 13-4`      Since: `Sept 2019`      Licence: `MIT`

== Introduction

*DIYeats* is an application designed to help NUS students plan out their diet in order to maintain a healthy lifestyle,
which can often times be a challenging endeavour amidst the intense academic rigour associated with university life.

*DIYeats* utilizes a command line interface, and is compatible with most modern OSes
(Windows, Macintosh, Linux, Ubuntu). Commands are designed to be simple and intuitive, such that even users who are
unfamiliar with the command line interface can use it with ease.

*DIYeats* also comes with a GUI wrapper for the command line interface.

To jump to a specific topic immediately, simply click on the topic in the <<toc, Table of Contents>> at the top

To improve the navigability and readability of this developer guide, multiple styles will be used, which will
include the following:

* User commands and parameters will displayed as: `format`
* Important keywords will be displayed as: *format*
* Keyboard buttons will be displayed as: kbd:[format]


Additionally, the following annotations will be used throughout this user guide:

[TIP]
====
This symbol denotes a tip which you may find useful when using the application.
====
[WARNING]
====
This symbol denotes a warning which you will need to be careful of when using the application.
====
[NOTE]
====
This symbol denotes some information or caveats that you will need to take note of when using the application.
====

== Setting up the project in your computer

=== Software prerequisites

. *JDK 11*
+
[NOTE]
Only JDK 11 is officially supported
. *IntelliJ IDE*
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.

=== Project setup
. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

== Design
=== Architecture
.Architecture Diagram
image::architecture.png[width="500"]

The figure above illustrates how our program might look like from a high-level perspective. Each of the major processes in the figure above will be elaborated on in the following sections.

`Main` has one function `run` which is executed immediately when the program is run. This function is responsible for:

* At application launch: initialize the UI, Model, Storage and Logic components of the code in the correct sequence

* During application runtime: support high level exchange of information between each of the aforementioned component

* At shutdown: Stop all running processes, and initiate any cleanup methods whenever required

=== Model
.Model Diagram : Meal Management
image::model.png[width="800"]

The Model component of the code is in charge of tracking and managing all of the meal data involved during the application's runtime. It accomplishes this by:

* Initializing a MealList object, which stores:
** All of the user's meal info
** All of the previously defined default meal values
* Initializing a Goal object, which stores the user defined dietary targets to be met.
* Being capable of operating independently of all the other code components.

.Model Diagram: Cost Management
image::Transaction_Diagram.png[width="800"]

The Model component of the code is in charge of managing the transaction data involved during the application's runtime. It accomplishes this by:

* Initializing a Wallet object which stores:
** A TransactionList which stores transactions (payment and deposit) and their attributes (e.g. transaction amount, dates of transaction).
** An Account object that stores the account balance as Amount.

=== Storage
.Storage Diagram
image::storage.png[width="800"]

The storage component of the code is in charge of reading and writing to files in the Data package of the main program directory. it accomplishes this by:

* Initializing a Load object, which:
** Is capable of reading and parsing data from the text save files in the Data directory, using its constituent functions as well as subsidiary classes.
** Being capable of operating independently of all the other code components.
* Initializing a Write object, which:
** Is capable of writing data to the text save files in the Data directory, using its constituent functions.
** Being capable of operating independently of all the other code components.

=== Logic
.Logic Diagram
image::logic.png[width="800"]

The Logic component of the code is in charge of parsing all of the user's commands and executing them. It accomplishes this in the following steps:

. The UI receives a command from the user, and sends it over to the Logic component
. The Parser object in the Logic component receives the command, and calls the autocorrect function to correct any typo errors present in the command
. The corrected command is inserted in the commandHistory
. Depending on the type of command issued, the parser calls the commandparser associated with the command, which parses the command into its relevant data chunks.
. A command object relevant to the user given command is then instantiated from the data in the user given command
. The command object is then passed to the main function, which immediately executes it

=== Ui
The Ui component of the code is in charge of:

. Executing all user commands through the Logic component
. Presenting data from the model component of the code to the user through the command line interface

== Implementation

As of now, all commands entered by the user go through the following validation checks:

. The autocorrect function takes in the user input, and determines if there are any typos present in the user input.
* If autocorrectable typos are present, the program attempts to replace the erroneous text with the correct command from a predetermined set of words.
* If no typos are present, or there exists a word that cannot be autocorrected, the command is returned as is to the parser.
. This autocorrected command is then subjected to additional checks in the `*CommandParser` class (e.g AddCommandParser, EditCommandParser, etc.), which ensures that the command structure is correct.

=== User initialization

User initialization personalises the program for each user to cater to their needs.

This section describes the implementation and design considerations.

==== Current implementation

On start up, `Main` will load `user.gson` file. If no data is found, `Main` class will instead ask for user information before starting the program.

The following step describes the flow of the initialisation:

. The `Main` class will load `user.gson` via `Storage` class and check if there is user data already stored.
.. If no data is found, `Main` will request for user to input personal data in this format:
... `/name <NAME> /age <AGE> /weight <WEIGHT> /height <HEIGHT> /activity <ACTIVITY_LEVEL> /gender <GENDER>`
.. If data is found, `Main` will load the data from `user.gson` via `Storage`
. The `Main` will continue on with the function.
. On any commands that updates `user` class, `Storage` will save the updated user class to `user.gson`

==== Design considerations

Problem 1: *How to store weight data to be displayed over time*

* Solution 1 (current implementation): HashMap
** By storing data in HashMap, we are able to store a weight data to a date and this can be changed easily by accessing the same date in the HashMap.

.User Initialisation sequence diagram
image::User_Sequenced_Diagram.png[width="800"]

=== Autocorrect

Autocorrect corrects user's input with minor typo to the correct word.

This section describes the implementation and design considerations

==== Current implementation

On start up, `Main` will load `word.txt` file.

The following step describes the flow of the initialisation:

. The `Main` class will load `word.txt` via `Storage` class and load the predefined word into an ArrayList
. During any word input, the word will be passed to the `Autocorrect` object and `Autocorrect` will execute and find the correct word based on the distance.
.. Distance in this case is defined as how many different letters there are between both words
. The program will compare the user input word with all of the predefined word and attempt to find the predefined word with the lowest distance
. If no words that are close enough are found, it will return the original word.

.User Initialisation sequence diagram

image::Autocorrect_Sequence_Diagram.png[width="800"]

=== Add Default value command

The `default` command gives the user the ability to assign default nutritional values associated with certain meal names.

This section describes the implementation and design considerations involved in the feature, and how the add default feature expedites user input.

==== Current implementation
Assuming that there are no preexisting default values assigned to meals, and the user inputs the `default` command `default hotcakes /calories 300`, the application processes the command through the following steps:

. The `Main` class calls the parse function of the `Parser` class to parse the user input.

. After parsing, the data is then used to create an instance of the `AddDefaultValueCommand` object, which is then returned to the `Main` function.
. The `Main` function would then invoke the `AddDefaultValueCommand#execute()` function.
. The `AddDefaultValueCommand#execute()` function then further invokes the `MealList#addDefaultValues(...)` function, which stores the data in a `storedItems` object of type `HashMap<String, HashMap<String, Integer>>`, in the following format:
* The key of the encapsulating hashmap is the name of the meal that is to be assigned default values, in this instance, it has only one member `hotcakes`
* The internal hashmap associated with the key `hotcakes` is used to store the nutritional tags (e.g calories, sodium, etc.), along with the default quantity associated with it. In this case, the internal hashmap only has one key `calories`, which is associated with the integer value `300`.

+
After the values are stored in the mealList container, control is returned to AddDefaultValueCommand.
. The AddDefaultValueCommand then invokes `Ui#showAddedItem()`, which displays the default value added to the user through the CLI. After the method executes, control is returned to AddDefaultValueCommand.
. AddDefaultValueCommand then invokes `Storage#writeDefaults()`, which writes the contents of storedItems in MealList to persistent storage. After the method executes, control is returned to AddDefaultValueCommand.
. AddDefaultValueCommand finishes execution, and returns control to main, which awaits the next user input.

The steps carried out by the program as described above are captured in figure 7, the sequence diagram as shown below.

.AddDefaultValue command sequence diagram
image::AddDefaultValueUML.png[width="800"]

==== Design considerations

Problem 1: *How to store the data associated with this command*

* Solution 1 (current implementation): Hashmap of a Hashmap
** By storing the data in this format, this feature can be easily extendable to store multiple different default values associated to different nutritional tags to a single meal. Additionally, read and write access can be carried out in approximately O(1) time. Thus the process is not time complex.
* Solution 2: Array of Pairs
** By assigning each default meal value to an array of pairs, with the nutrition type as the key and the amount of nutrition as the value, data can be stored in a less complex data structure as compared to hashmap. However, the lookup time for each nutrition type is now O(n), where n is the number of nutrients associated to a default value. Hence, solution 1 was chosen over solution 2, due to its faster access times.
Problem 2: *Where to instantiate the data structure used to store the data for this command*

* Solution 1 (current implementation): Directly in the MealList data structure
** By instantiating the data structure directly in the MealList data structure, it becomes straightforward to access the data whenever a new meal is added.
** However, this might violate the separation of concerns architecture principle
* Solution 2: In a separate class
** By instantiating the data structure in a different class, it improves the cohesion of the code, and satisfies the separation of concerns principle. However, close interaction between default meal values and the the MealList data structure might result in close coupling of the two classes, which is undesirable.


=== Mark as Done command

The Mark as Done feature gives the user the ability to mark the meals they have eaten as done and this will update the calorie they can eat for the rest of the day, the application processes the command through the following steps:

==== Current Implementation
Assuming that the index in the user input is not outside the boundary of the meals on that certain day, the implementations are as follows:

. The `Main` class calls the parse function of the `Parser` class to parse the user input which consist of the index of meal marked done and the specified date.
. After parsing, the data parsed is used to create an instance `MarkDoneCommand` object, which is the returned to the `Main` function.
. The `Main` function would then invoke the `MarkDoneCommand#execute()` function.
. The `MarkDoneCommand#execute()` function will invoke the function `MealList#markDone(...)` which update the state of the specified meal as done (unless the meal is already marked done).
. The `MarkDoneCommand#execute()` function will also invoke `wallet#addPaymentTransaction` which will deduct the user's account balance depending on whether the food cost is larger than their current account balance.
. The `MarkDoneCommand#execute()` function will also invoke the `ui#showCaloriesLeft` which will calculate the amount of calories left to be eaten in that day.

.Mark as Done command sequence diagram
image::Done_Command_UML.png[]

=== Transaction command

The Transaction feature gives the user the ability to manage their accounts when to economise when choosing their meals.

==== Current Implementation
Assuming that there is enough balance in the user account, the application processes the commands through the following steps:

. The `Main` class calls the parse function of the `Parser` class to parse the user input.
. After parsing, the data parsed are then used to create an instance of the `AddTransactionCommand` object, which is then returned to the `Main` function.
. The `Main` function would then invoke the `AddTransactionCommand#execute()` function.
. The `AddTransactionCommand#execute()` function the furthers invokes the 'user#updateAccount(...)' function, which update the data of the account balance of the user.

.Add Transaction command sequence diagram
image::SD_AddTransaction.png[]

==== Design considerations

Problem 1: *What data type should represent cost/money in?*

* Solution 1 : Double or Float
** The first data types that comes up are either float or double data ype.
** However, float and double are prone to floating point error, which poses an accuracy problem for money calculation.

* Solution 2 : Int or Long
** Int and Long is more appropriate to be used to calculate money since they do not have precision error.
** However, we need additional calculations to calculate amount that includes cents. For example, the first digit represents cents and the third digit represents dollars.
** Moreover, int only works for number with digits not more than 9 and long with digits not more than 18.

* Solution 3 : BigDecimal (current Implementation)
** This data type is superior since it has built-in rounding modes and has higher range than long and int.
** Moreover, BigDecimal is able to represent decimal values and perform decimal calculations reliably.
** Therefore, values such as "1.2345" are allowed and any calculation on it will generate accurate value.

Problem 2: *Where do we store user's account?*

* Solution 1 : Together with the user class
** It maybe the first choice for most people.
** However, it violates the single responsibility principle and it is easily readable by other developers.
** Moreover, the constraint of the project states to have one user only.

* Solution 2 : Create a separate wallet package (current Implementation)
** It is more well organized and both user and wallet is not very strongly coupled to each other.
** Hence, it improves code quality and readability.

=== List Command

The list command gives the user the ability to display the list of meals on a particular date.

==== Current Implementation
. The `Main` class calls the parse function of the `Parser` class to parse the user input.
. After parsing, the data is then used to create an instance of the `ListCommand` object, which is then returned to the `Main` function.
. The `Main` function would then invoke the `ListCommand#execute()` function.
. The `ListCommand#execute()` function will then sort the data by invoking `ArrayList<Meal>#sort(...)` based on the sorting criterion specified by calling custom comparator `SortMealByCalorie`, `SortMealByCost`, or `SortMealByDefault`.
. The ListCommand then invokes `Ui#showMealList` to display the mealList based on the sorting criterion specified by the user.
. `Ui#showCaloriesLeft`, and `Ui#showExercisesOnDate` are further invoked to add additional information.

.List command sequence diagram
image::List_Command_UML.png[]

==== Design considerations

Problem 1: *How to order a user-defined classes with multiple comparable fields?*

* Solution 1: Write our own sort() function using one of the standard algorithms.

** Pros: The most obvious way

** Cons: Requires rewriting the whole sorting code for different criterion.

* Solution 2: Using comparator interface (current implementation)

** Pros: Elegant and accordant to the Interface Segregation Principle (ISP). By using the comparator interface, there is no need to write implementation of the sort, instead the program will just override
the compare criterion.

Problem 2: *How to order meals in breakfast, lunch, dinner (in that order)*

* Solution 1: Assign number to breakfast, lunch, dinner in ascending(or descending order) and sort accordingly.

** Pros: Simple and to the point.

** Cons: Lacks elegance since it uses magic number.

* Solution 2: Use enum class' comparable property (current implementation)

** Pros: Based on the knowledge that enum class has a comparable property and compares the ordinal value of the enum instances.
We could order the enum class such that it will be breakfast, lunch, and dinner then assign it to the mealType and sort accordingly.

=== Suggestmeal Command

The `suggestmeal` command provides the user the ability to get personalized meal recommendations from our application based on the current database of food available in our application as well as the food habits of the user, all while ensuring the user has a healthy meal that matches his/her lifestyle and calorie limit.

The following section describes the implementation and design considerations involved in the `suggestmeal` feature, and how the `suggestmeal` feature facilitates meal recommendations.

==== Current implementation
The Suggest command assumes that there is a pre-existing list of food items from which it can suggest food from and that this list contains food parameters such as cost, calories, nutrients, etc. This is a sample of how this feature will work in principle:

. The `Main` class calls the parse function of the `Parser` class to parse the user input.

. After parsing, the data is then used to create an instance of the `SuggestMealCommand` object, which is then returned to the `Main` function.
. The `Main` function would then invoke the `SuggestMealCommand#execute()` function.
. The `SuggestMealCommand#execute()` function executes the first stage of user data processing and calls `SuggestMealCommand#execute_stage_0` function, which calls the `MealSuggestionAnalytics#getMealSuggestions(...)` function.
. The `MealSuggestionAnalytics#getMealSuggestions(...)` function loads the default meal item list data in a `SuggestMeal` data model object, which inherits the `Meal` class, which has object comparison order implemented in `SuggestMeal#compareTo(...)`.
. `SuggestMeal` objects that meet the calorie requirement are sorted and an arrayList of `Meal` objects is returned, which contains the possible meals that the user can choose from.
. The `SuggestMealCommand#execute()` function then moves on to the next stage of data enquiry from user for meal selection and passes the input choice to `SuggestMealCommand#execute_stage_1` function, which then invokes the `AddCommand#execute` to add the selected meal to the application.


.Suggest Meal Command sequence diagram
image::SuggestMealCommand_Sequence_Diagram.png[]


==== Design considerations

Problem 1: *How to determine most suitable meal for user*

* Solution 1 (Current Implementation): Use the calories as the determining factor and sort the calories from highest to lowest and suggest meals that meet the calorie limit left for the day.

** Pros: Easy to implement and deterministic behaviour.

** Cons: Does not consider other factors such as cost and other food nutrients (calcium, etc).

* Solution 2 : Calculate the ranking of each parameter of each meal with the rest of the meals and provide meal suggestion based on the meal with the lowest ranking in as many of the parameters specified by the user.

** Pros: Allows comparison among multiple meal parameters for a more holistic meal suggestion.

** Cons: Not all meals have all the tags specified as only `calorie` tag is common for all the meals.



=== Update Command

The Update Command provides the user with a method of updating their personal data so the program can be better tailored for them

The following section describes the implementation and design considerations involved in the Update feature.

==== Current implementation
The user is able to specify which information to update via tags `/name`, `/age`, `/weight`, `/height` and `/activity`

. User will specify the parameters of the data to be updated
. After parsing through the input, `Parser` will make sense of the data and return a `UpdateCommand`.
. `UpdateCommand` will then check for the existence of the tags
. If the tag exists, it'll call for the appropriate function to update.
.. For example, if `/age` exists, it'll call `UpdateAgeCommand` to update the user's age.
. As `weight` is tracked over time for graphing and statistic purposes, the user is also able to specify the date of the weight to be inserted in via `/date` parameter.
. If `UpdateWeightCommand` detects the existence of a `weight` on that particular `date`, it'll return to `Main` to request for confirmation of the user to overwrite the data.
. After `UpdateCommand` is done updating the `user`, it will call `storage` to update `user.json`

=== Graph Command

The Graph Command provides a visualisation of the data specified by the user over a month so they are able to better adjust their choices of meals

The following section describes the implementation and design considerations involved in the Graph feature and how it outputs the graph onto command line.

==== Current implementation
The user can specify the month and year of the category of data they would like to view as a plotted graph. The implementation is as follows:

. User will specify the parameters of the data.
. After parsing through the user input, `Parser` will make sense of the input and return a `GraphCommand` with the relevant `type`, `month` and `year`.
. `GraphCommand` will then check the `type` and obtain the relevant data from the relevant objects.
.. For example, if the `type` is specified as `weight`, `GraphCommand` will obtain the `weight` data from `User`.
. After obtaining the data in the form of a `HashMap`, `GraphCommand` will run through the `HashMap` by checking for all dates in the specified `month` and `year`.
.. If a date is not found in the `keySet` of the `HashMap`, the data for that date will be assumed to be 0.
. The data found for each date is stored in an `ArrayList`.
. The biggest data found will also be stored as a variable called `highest`. This will be used for scaling of the graph.
. From this `ArrayList`, each data is scaled according to the `highest` variable stored and plotted accordingly in a 2-dimensional `Array`.
. This `Array` will then be passed to `GraphUi` for it to plot the graph on the commandline.

==== Design considerations

Problem 1: *How to output the x axis for days appropriately so that the double digits do not mess up the command line scaling*

* Solution 1: Print the 1st digit in the first line, and the 2nd digit on the second line.

** Pros: All day values are able to be displayed using one character space.

** Cons: It takes up an additional line of space

Problem 2: *Preventing data from being too large and taking too much space*

* Solution 1: Find the highest value of the data, and scale all of the values according to the highest value.

** Pros: Data can output on the graph without exceeding limits. Users are able to see the fluctuation of the values.

** Cons: Users are unable to check the exact value of each points.

* Solution 1: Output the data according to the number of space.

** Pros: Users are able to check the exact value of each points.

** Cons: If the data is too big, it may go out of the intended graph range and the desired output may be skewed. This may prevent users from being able to accurately see their progress.

.CGraph command sequence diagram
image::Graph_Command.png[width="800"]


=== Edit Command

The `edit` command provides the user the ability to update existing meals in their food tracker on any date instead of deleting and re-adding a meal with a slightly different description.

The following section describes the implementation and design considerations involved in the edit feature, and how the edit feature facilitates seamless meal tracking via intuitive meal updates.

==== Current implementation
The edit command assumes that there is a pre-existing list of food items being tracked by the user This is a sample of how this feature will work in principle:

. The `Main` class calls the parse function of the `Parser` class to parse the user input.

. After parsing, the data is then used to create an instance of the `EditCommand` object, which is then returned to the `Main` function.
. The `Main` function would then invoke the `EditCommand#execute()` function.
. During execution, the `EditCommand#getUpdatedMeal()` gets the updated meal details and `MealList#updateMealList()` updates the meal data for the `MealList` model.
. The updated meal data is saved to storage via `Storage#writeFile()`.


.Edit Command sequence diagram
image::EditCommand_Sequence_Diagram.png[]


==== Design considerations

Problem 1: *How should meals be updated?*

* Solution 1: Update the meal by the meal name on the date specified.

** Pros: It is easier for the user to remember the meal that they had just input recently that they want to update.

** Cons: It will face issues if there are multiple meals on the same day with the same name.

* Solution 2 (Current Implementation): Update the meal by the meal index as shown via list command.

** Pros: No issues faced in dealing with multiple meals with the same names or tags.

** Cons: Requires user to type `list` before editing the meal as they need to know the index at which the meal must be updated.





== Documentation
=== Introduction

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Docs-SiteWideDocSettings]]
=== Site-wide Documentation Settings

The link:{repoURL}/build.gradle[`build.gradle`] file specifies some project-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how all documentation files within this project are rendered.

[TIP]
Attributes left unset in the `build.gradle` file will use their *default value*, if any.

[cols="1,2a,1", options="header"]
.List of site-wide attributes
|===
|Attribute name |Description |Default value

|`site-name`
|The name of the website.
If set, the name will be displayed near the top of the page.
|_not set_

|`site-githuburl`
|URL to the site's repository on https://github.com[GitHub].
Setting this will add a "View on GitHub" link in the navigation bar.
|_not set_

|`site-seedu`
|Define this attribute if the project is an official SE-EDU project.
This will render the SE-EDU navigation bar at the top of the page, and add some SE-EDU-specific navigation items.
|_not set_

|===

[[Docs-PerFileDocSettings]]
=== Per-file Documentation Settings

Each `.adoc` file may also specify some file-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how the file is rendered.

Asciidoctor's https://asciidoctor.org/docs/user-manual/#builtin-attributes[built-in attributes] may be specified and used as well.

[TIP]
Attributes left unset in `.adoc` files will use their *default value*, if any.

[cols="1,2a,1", options="header"]
.List of per-file attributes, excluding Asciidoctor's built-in attributes
|===
|Attribute name |Description |Default value
|`site-section`
|Site section that the document belongs to.
This will cause the associated item in the navigation bar to be highlighted.
One of: `UserGuide`, `DeveloperGuide`, `AboutUs`, `ContactUs`
|_not set_
|`no-site-header`
|Set this attribute to remove the site navigation bar.
|_not set_

|===

== Testing
=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


== Dev Ops
=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects. See <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews

When a pull request has changes to asciidoc files, you can use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of those asciidoc files will look like when the pull request is merged. See <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the https://github.com/FasterXML/jackson[Jackson library] for JSON parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives:

[loweralpha]
. Include those libraries in the repo (this bloats the repo size)
. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Value Propositions

**Target User Profile:**

NUS Students who are trying to plan their meals for a specific diet goal such as losing weight, maintaining weight, or building muscle.

**Propositions:**

* DIYeats makes it radically easy to maintain and keep track of your daily nutritional intake in a single Command Line Interface (CLI) and Graphical User Interface (GUI).
* DIYeats lets you set your own weight goal based on your height and your activity level.
* DIYeats gives you liberty to follow any eating style and create your own customized meals.
* DIYeats allows you to plan ahead and reduce the food waste due to overshopping groceries.
* DIYeats plans on integrating all food items in NUS into its database, which can allow it to suggest meals in NUS that would allow the user to meet their nutritional targets.
* DIYeats elegantly displays the progress of your diet to help you motivate yourself and others.
* DIYeats saves your effort and efficiently suggest and plan the meals for you.

[appendix]
== User Stories
[width="80%",cols="20%,<20%,<30%,<30%",options="header",]
|=======================================================================
|Priority |As a... |I want to... |So that I can...
|HIGH |NUS student |be able to plan my meals ahead |I know beforehand what to eat the next day, amidst my busy schedule
|HIGH |NUS student |list of dishes and each nutritional value in NUS Canteens| I can make an informed decisions to pick healthier meal
|HIGH |NUS sportsman |track the amount of nutrition I need to take in a day |I can plan my meal and avoid overeating/undereating
|HIGH |someone looking to lose weight |track the daily calories intake based on my target body weight |I am able to regulate the amount of food I eat in the day
|HIGH |unregistered user |create a customized profile of myself (e.g. weight and height)| I don’t have to input the profile every time I open the application
|HIGH |vegetarian |create a meal plan that does not require meat or dairy product |I could eat healthy with my vegetarian preference
|MEDIUM |someone who is not great at typing |an autocorrect feature |I don’t input incorrect dish names
|MEDIUM |forgetful user |remind myself of the available commands in an application |I don’t have to waste my time rustling through user guide
|MEDIUM |forgetful user |have a way to remind me how much nutrition I have to take to reach the target nutrient intake |I could plan my subsequent meal accordingly
|MEDIUM |careless user |be able to revert changes done previously |I don’t have to manually revert the changes
|MEDIUM |efficient user |clear and add multiple meals at once |I don’t have to input the same command multiple times
|MEDIUM |efficient user |add a recurring meal (every week, biweekly) |I don’t have same command multiple times
|MEDIUM |cautious user |have a way to detect when a planned meal in the future is higher than the average required intake |I won’t accidentally exceed the quota
|LOW |someone who appreciates keyboard shortcuts |have a way to recognize short forms of keywords used in the app |I can work faster
|LOW |someone who likes to motivate people |have a way to print my progress in the past month |I can motivate other people to live healthily
|LOW |someone likes different themes |have a way to change the color scheme of the application |it is easier to the eyes.
|LOW |someone likes different themes |have different colors for different tasks |I am able to distinguish between them easily.
|=======================================================================

[appendix]
== Use Cases
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC01 - Customizing User Profile

Main Success Scenario:

1. DIYeats detects that user profile has not been specified and prompts for information regarding height, weight, and lifestyle

2. Student enters the required information based on his profile

3. DIYeats indicates that user profile has been recorded.

Use case ends.

Extensions:

2.1: DIYeats detects an error in the entered data.

2.1.1: DIYeats requests for the correct data.

2.1.2: Student enters new data.

Steps 2.1.1 - 2.1.2 are repeated until the data entered are correct.

Use case resumes from step 3.

3.1: Student requests to change the user profile.

Use case resumes from step 1.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC02 - Planning Meals

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile)

Main Success Scenario:

1. Student chooses the food he/she is planning to eat and corresponds the food to the respective meal.

2. DIYeats indicates the meal has been recorded.

3. Steps 1-2 are repeated until Student has inputted all the meals intended

Use case ends.

Extensions:

1.1: Student wants to record a meal that happened before the current day.

1.1.1: Student specifies the past date the meal occurred.

Use case resumes from step 2.

1.2: Student wants to change the nutritional value of the meal

1.2.1:  Student specifies the nutritional value of the meal.

Use case resumes from step 2.

1.3: DIYeats detects that the nutritional value exceeds the average required intake.(which is set up in UC07- Set Goal Intake)

1.3.1: DIYeats warn the Student of the anomaly and ask for confirmation/modify request.

1.3.2: Student modifies the input data or confirm the input.

Use case resumes from step 2.

1.4: DIYeats detects the wrong input from Student.

1.4.1: DIYeats prompts Student to re-enter the command.

1.4.2: Student enters the command.

Steps 1.4.1 - 1.4.2 are repeated until the command entered are correct.

Use case resumes from step 2.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC03 - List Meals

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals are entered. (Refer to UC02 - Planning Meals).

Main Success Scenario:

1. NUS Student requests to display meal and the nutritional intake for today.

2. DIYeats display the recorded meals taken / will be taken today and its nutritional value.

Use Case Ends.

Extensions:

1.1: NUS Student wants to specify a date other than today

1.1.1: DIYeats display the recorded meals and intake on that date

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC04 - Remind Meals

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals are entered. (Refer to UC02 - Planning Meals).

Main Success Scenario:

1. User requests to be reminded on how much nutrition the student intake to reach the target nutrient intake for the month.

2. DIYeats display the information.

Use Case Ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC05 - Find meal(s)

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals are entered. (Refer to UC02 - Planning Meals).

Main Success Scenario:

1. Student requests to find a specific food student had in the past

2. DIYeats displays the queried food and its description.

Use case ends.

Extensions:

1.1: DIYeats does not recognize the food requested

1.1.1: DIYeats displays the error message.

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC06 - Delete meal

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals can be found. (Refer to UC05 - Find meal(s)).

Main Success Scenario:

. Student requests to delete a specific food student had in the past.
. DIYeats displays the queried food and its description and the confirmation message.

Use case ends.

Extensions:

1.1: DIYeats does not recognize the food requested.

1.1.1: DIYeats displays the error message.

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC07 - Set Goal Intake

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile).

Main Success Scenario:

1. Student requests for nutritional goals to be met at the end of a time frame (end of month)

2. DIYeats displays the nutritional goals that have been inputted and a confirmation goals.

3. Use case ends.

Extensions:

1.1: DIYeats detects an error in the entered data.

1.1.1: DIYeats requests for the correct data.

1.1.2: Student enters new data.

Steps 1.1.1 - 1.1.2 are repeated until the data entered are correct.

Use case resumes from step 2.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC08 - Meal Recommendation

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Some meals already eaten. ( Refer to UC02 - Planning Meals). Goal intake set. (Refer to UC07 - Set Goal Intake).

Main Success Scenario:

1. Student unsure of what food to eat for the next meal and asks DIYeats to recommend a food that fits within the goal intake set.

2. DIYeats displays a small list of nutritional food that fit within the goal intake plan set by the student.

3. Student can choose to select food from the list generated in step 2 or proceed to key in any other food as per normal.

Use case ends.

Extensions:

1.1: DIYeats has a customizable recommendation system.

1.1.1: Student filters recommended list by meals by meal type          (only recommend food which was eaten for lunch and not dinner).

Step 1.1.1 is repeated until the student is satisfied with the constraints for food recommendation.

Use case resumes from step 2.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC09 - Generate Statistics

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Some meals already eaten. ( Refer to UC02 - Planning Meals). Goal intake set. (Refer to UC07 - Set Goal Intake).

Main Success Scenario:

1. Student requests for the statistics of the amount of nutrients that have been eaten in a specific time frame.

2. DIYeats displays the statistics, accompanied by the goal intake that is set by the student.

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC10 - Generate Graphs

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Some meals already eaten. ( Refer to UC02 - Planning Meals). Goal intake set. (Refer to UC07 - Set Goal Intake).

Main Success Scenario:

1. Student requests for the graph of the amount of nusugtrients that have been eaten in a specific time frame.

2. DIYeats displays the graph, accompanied by the goal intake that is set by the student.

Use case ends.
|=======================================================================


[appendix]
== Non-functional Requirements

* The data (user profile, meal plans, and schedule) should be persistent even if the user terminates the applications.
* The user interface should be intuitive enough to be used by a new user who has never been introduced to the program.
* The system must respond fast enough and feels snappy.
* The program must be able to be used in different platforms/operating systems (Linux, Windows, and Macintosh).
* The source code must be documented properly and adhere to the coding standards to be easily read by new developers that intend to contribute to the projects.
* The application must not violate intellectual property rights or export of restricted technologies. The third party libraries used must be approved and open source in nature.

[appendix]
== Glossary

* *Current date*: Date obtained from the system date in user’s local machine.
* *Meal*: Only includes breakfast, lunch, and dinner.
* *Session*: A period of time where the user interacts with the application. The session begins when the user launches the application, and ends when the user terminates the application.

[appendix]
== Instructions for manual testing

[TIP]
====
This is only a guideline to test some features in our application, and by all means should not limit the tester from engaging in their own variants of testing
====
* *Initial Setup*
. Launch
.. Download our jar file from the website
.. Using your computer's command line, navigate to the directory the jar file is in
.. Launch the jar file using the command `java -jar DIYeats-1.4.jar
. Persistent data storage during runtime
.. Runtime data will be stored in a folder in the same directory as the jar file.
.. Tempering with the save file may cause data corruption, do so with care.
. Exiting the application
.. Enter the command `bye` and the program should exit with a exit message.

* *Updating user*
+
The application comes preloaded with a user profile. However, if you wish to customize the user data to match yourself, you can use
the `update` command to update user information.

* *SetGoal command*
. Test case 1:
** Enter `setgoal /start 11/11/2019 /end 11/11/2020 /activity 5 /weight 60`
** Program should say setgoal successful, unless the user details were modified

* *SuggestExercise command*
. Test case 1:
** Enter `suggestexercise`
** Program should show a list of exercise suggestions. Pick an index to select it as your exercise for the day. If a goal has not been properly set, an error message will be shown.

* *List command*
. Test case 1:
** Enter `list`
** Program should show you a list of your meals for the day. If no meals are present, none will be presented.

* *SuggestMeal command*
. Test case 1:
** Enter `suggestmeal`
** Program should show a list of meal suggestions. Pick a meal index to add it to your meals for the day
** If you have hit or are close to hitting your calorie limit for the day, the command will not suggest any meals for you.

* *Breakfast command*
. Test case 1:
** Enter `breakfast hotcakes /calorie 600`
** Program will show that a breakfast item named "hotcakes" has been added to the list of meals. Use the `List` command to see a list of currently recorded meals. There should be an entry identical to the one you entered in the list

* *default command*
.Test case 1 :
** Enter `default roti chanai /calorie 500`
** Program will prompt you that a default value has been assigned to food item "roti chanai"
** Now, enter `lunch roti chanai`
** Program will show that a rotai chanai item with 500 calories associated to it has been added. 

