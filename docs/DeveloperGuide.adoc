= DIYeats - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toclevels: 2
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:warning-caption: :warning:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2113T-W13-4/main

By: `Team 13-4`      Since: `Sept 2019`      Licence: `MIT`

== Introduction

*DIYeats* is an application designed to help NUS students plan out their diet in order to maintain a healthy lifestyle,
which can often times be a challenging endeavour amidst the intense academic rigour associated with university life.

*DIYeats* utilizes a command line interface, and is compatible with most modern OSes
(Windows, Macintosh, Linux, Ubuntu). Commands are designed to be simple and intuitive, such that even users who are
unfamiliar with the command line interface can use it with ease.

*DIYeats* also comes with a GUI wrapper for the command line interface.

To jump to a specific topic immediately, simply click on the topic in the <<toc, Table of Contents>> at the top

To improve the navigability and readability of this developer guide, multiple styles will be used, which will
include the following:

* User commands and parameters will displayed as: `format`
* Important keywords will be displayed as: *format*
* Keyboard buttons will be displayed as: kbd:[format]


Additionally, the following annotations will be used throughout this user guide:

[TIP]
====
This symbol denotes a tip which you may find useful when using the application.
====
[WARNING]
====
This symbol denotes a warning which you will need to be careful of when using the application.
====
[NOTE]
====
This symbol denotes some information or caveats that you will need to take note of when using the application.
====

== Setting up the project in your computer

=== Software prerequisites

. *JDK 11*
+
[NOTE]
Only JDK 11 is officially supported
. *IntelliJ IDE*
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.

=== Project setup
. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

== Design
=== Architecture
.Architecture Diagram
image::architecture.png[width="500"]

The figure above illustrates how our program might look like from a high-level perspective. Each of the major processes in the figure above will be elaborated on in the following sections.

`Main` has one function `run` which is executed immediately when the program is run. This function is responsible for:

* At application launch: initialize the UI, Model, Storage and Logic components of the code in the correct sequence

* During application runtime: support high level exchange of information between each of the aforementioned component

* At shutdown: Stop all running processes, and initiate any cleanup methods whenever required

=== Model
.Model Diagram : Meal Management
image::model.png[width="800"]

The Model component of the code is in charge of tracking and managing all of the meal data involved during the application's runtime. It accomplishes this by:

* Initializing a MealList object, which stores:
** All of the user's meal info
** All of the previously defined default meal values
* Initializing a Goal object, which stores the user defined dietary targets to be met.
* Being capable of operating independently of all the other code components.

.Model Diagram: Cost Management
image::transactionmodel.png[width="800"]

The Model component of the code is in charge of managing the transaction data involved during the application's runtime. It accomplishes this by:

* Initializing a TransactionList object, which stores
** All of the transactions information (e.g. transaction amount, dates of transaction).
* Being capable of operating independently of all the other code components.

=== Storage
.Storage Diagram
image::storage.png[width="800"]

The storage component of the code is in charge of reading and writing to files in the Data package of the main program directory. it accomplishes this by:

* Initializing a Load object, which:
** Is capable of reading and parsing data from the text save files in the Data directory, using its constituent functions as well as subsidiary classes.
** Being capable of operating independently of all the other code components.
* Initializing a Write object, which:
** Is capable of writing data to the text save files in the Data directory, using its constituent functions.
** Being capable of operating independently of all the other code components.

=== Logic
.Logic Diagram
image::logic.png[width="800"]

The Logic component of the code is in charge of parsing all of the user's commands and executing them. It accomplishes this in the following steps:

. The UI receives a command from the user, and sends it over to the Logic component
. The Parser object in the Logic component receives the command, and calls the autocorrect function to correct any typo errors present in the command
. The corrected command is inserted in the commandHistory
. Depending on the type of command issued, the parser calls the commandparser associated with the command, which parses the command into its relevant data chunks.
. A command object relevant to the user given command is then instantiated from the data in the user given command
. The command object is then passed to the main function, which immediately executes it

=== Ui
The Ui component of the code is in charge of:

. Executing all user commands through the Logic component
. Presenting data from the model component of the code to the user through the command line interface

== Implementation

As of now, all commands entered by the user go through the following validation checks:

. The autocorrect function takes in the user input, and determines if there are any typos present in the user input.
* If autocorrectable typos are present, the program attempts to replace the erroneous text with the correct command from a predetermined set of words.
* If no typos are present, or there exists a word that cannot be autocorrected, the command is returned as is to the parser.
. This autocorrected command is then subjected to additional checks in the `*CommandParser` class (e.g AddCommandParser, EditCommandParser, etc.), which ensures that the command structure is correct.

=== User initialization

User initialization personalises the program for each user to cater to their needs.

This section describes the implementation and design considerations.

==== Current implementation

On start up, `Main` will load `user.txt` file. If no data is found, `Main` class will instead ask for user information before starting the program.

The following step describes the flow of the initialisation:

. The `Main` class will load `user.txt` via `Storage` class and check if there is user data already stored.
.. If no data is found, `Main` will request for user to input personal data in this order:
... `Name`
... `Age`
... `Weight`
... `Height`
... `Activity Level`
... If they would like to maintain or lose weight
.. If data is found, `Main` will load the data from `user.txt` via `Storage`
. The `Main` will continue on with the function.
. On any commands that updates `user` class, `Storage` will save the updated user class to `user.txt`

==== Design considerations

Problem 1: *How to store weight data to be displayed over time*

* Solution 1 (current implementation): HashMap
** By storing data in HashMap, we are able to store a weight data to a date and this can be changed easily by accessing the same date in the HashMap.

.User Initialisation sequence diagram
image::usersequencediagram.png[width="800"]

=== Add command

The Add feature gives the user the ability to assign default nutritional values associated with certain meal names.

This section describes the implementation and design considerations involved in the Add feature, and how the Add feature expedites user input.

==== Current implementation
Assuming that there are no preexisting default values assigned to meals, and the user inputs the `add` command `add hotcakes /calories 300`, the application processes the command through the following steps:

. The `Main` class calls the parse function of the `Parser` class to parse the user input.

. After parsing, the data is then used to create an instance of the `AddItemCommand` object, which is then returned to the `Main` function.
. The `Main` function would then invoke the `AddItemCommand#execute()` function.
. The `AddItemCommand#execute()` function then further invokes the `MealList#addStoredItem(...)` function, which stores the data in a `storedItems` object of type `HashMap<String, HashMap<String, Integer>>`, in the following format:
* The key of the encapsulating hashmap is the name of the meal that is to be assigned default values, in this instance, it has only one member `hotcakes`
* The internal hashmap associated with the key `hotcakes` is used to store the nutritional tags (e.g calories, sodium, etc.), along with the default quantity associated with it. In this case, the internal hashmap only has one key `calories`, which is associated with the integer value `300`

The steps carried out by the program as described above are captured in figure 5, the sequence diagram as shown below.

.Add command sequence diagram
image::addcommand.png[width="800"]

==== Design considerations

Problem 1: *How to store the data associated with this command*

* Solution 1 (current implementation): Hashmap of a Hashmap
** By storing the data in this format, this feature can be easily extendable to store multiple different default values associated to different nutritional tags to a single meal. Additionally, read and write access can be carried out in approximately O(n) time, where n is the amount of nutritional tags associated to a single meal. As n is unlikely to be large (n > 10), the process is not time complex.

Problem 2: *Where to instantiate the data structure used to store the data for this command*

* Solution 1 (current implementation): Directly in the MealList data structure
** By instantiating the data structure directly in the MealList data structure, it becomes straightforward to access the data whenever a new meal is added.
** However, this violates the separation of concerns architecture principle
* Solution 2 (planned implementation by v1.3): In a separate class
** By instantiating the data structure in a different class, it improves the cohesion of the code, and satisfies the separation of concerns principle


=== Mark as Done command

The Mark as Done feature gives the user the ability to mark the meals they have eaten as done and this will update the calorie they can eat for the rest of the day, the application processes the command through the following steps:

==== Current Implementation
Assuming that the index in the user input is not outside the boundary of the meals on that certain day, the implementations are as follows:

. The `Main` class calls the parse function of the `Parser` class to parse the user input which consist of the index of meal marked done and the specified date.
. After parsing, the data parsed is used to create an instance `MarkDoneCommand` object, which is the returned to the `Main` function.
. The `Main` function would then invoke the `MarkDoneCommand#execute()` function.
. The `MarkDoneCommand#execute()` function will invoke the function `MealList#markDone(...)` which update the state of the specified meal.
. The `MarkDoneCommand#execute()` function will also invoke the `ui#showCaloriesLeft` which will calculate the amount of calories left to be eaten in that day.

=== Transaction command

The Transaction feature gives the user the ability to manage their accounts when to economise when choosing their meals.

==== Current Implementation
Assuming that there is enough balance in the user account, the application processes the commands through the following steps:

. The `Main` class calls the parse function of the `Parser` class to parse the user input.
. After parsing, the data parsed are then used to create an instance of the `AddTransactionCommand` object, which is then returned to the `Main` function.
. The `Main` function would then invoke the `AddTransactionCommand#execute()` function.
. The `AddTransactionCommand#execute()` function the furthers invokes the 'user#updateAccount(...)' function, which update the data of the account balance of the user.

image::SD_AddTransaction.png[width="800]

==== Design considerations

Problem 1: *What data type should represent cost/money in?*

* Solution 1 : Double or Float
** The first data types that comes up are either float or double data ype.
** However, float and double are prone to floating point error, which poses an accuracy problem for money calculation.

* Solution 2 : Int or Long
** Int and Long is more appropriate to be used to calculate money since they do not have precision error.
** However, we need additional calculations to calculate amount that includes cents. For example, the first digit represents cents and the third digit represents dollars.
** Moreover, int only works for number with digits not more than 9 and long with digits not more than 18.

* Solution 3 : BigDecimal (current Implementation)
** This data type is superior since it has built-in rounding modes and has higher range than long and int.
** Moreover, BigDecimal is able to represent decimal values and perform decimal calculations reliably.
** Therefore, values such as "1.2345" are allowed and any calculation on it will generate accurate value.

Problem 2: *Where do we store user's account?*

* Solution 1 : Together with the user class
** It maybe the first choice for most people.
** However, it violates the single responsibility principle and it is easily readable by other developers.
** Moreover, the constraint of the project states to have one user only.

* Solution 2 : Create a separate wallet package
** It is more well organized and both user and wallet is not very strongly coupled to each other.
** Hence, it improves code quality and readability.

=== Sort command (will be implemented in v1.4)

The Sort feature gives the user the ability to sort the data according to nutritional value or based on costs.

This section describes the tentative implementation and design considerations involved in the Sort feature and how the Sort feature works.

==== Projected implementation
In the event where the user would like to sort the default meals from the least amount of calorie, the user inputs `sort /calories /ascending`, the application processes the command through the following steps:

. The `Main`` class calls the parse function of the `Parser` class to parse the user input. During this stage, the following validation checks are carried out before parsing:
. After parsing, the data is then used to create an instance of `Sortcommand`, which is then returned to the `Main` function.
. The `Main` function would then invoke the the `SortCommand#execute` function.
. The `SortCommand#execute()` function then sort the invoke the `storage#LoadFile` function, which fetches the data from the default meal text file and update the generate a mealList.
. The mealList will then be sorted based on the calorie content in ascending order and and displayed to the user through `ui#showList`.






=== Suggest  command

The Suggest command provides the user the ability to get personalized meal recommendations from our application based on the current database of food available in our application as well as the food habits of the user, all while ensuring the user has a healthy meal that matches his/her lifestyle and calorie limit.

The following section describes the implementation and design considerations involved in the Suggest feature, and how the Suggest feature facilitates meal recommendations.

==== Current implementation
The Suggest command assumes that there is a pre-existing list of food items from which it can suggest food from and that this list contains food parameters such as cost, calories, nutrients, etc. This is a sample of how this feature will work in principle:

. The `Main` class calls the parse function of the `Parser` class to parse the user input.

. After parsing, the data is then used to create an instance of the `SuggestMealCommand` object, which is then returned to the `Main` function.
. The `Main` function would then invoke the `SuggestMealCommand#execute()` function.
. The `SuggestMealCommand#execute()` function executes the first stage of user data processing and calls `SuggestMealCommand#execute_stage_0` function, which calls the `MealSuggestionAnalytics#getMealSuggestions(...)` function.
. The `MealSuggestionAnalytics#getMealSuggestions(...)` function loads the default meal item list data in a `SuggestMeal` data model object, which inherits the `Meal` class, which has object comparison order implemented in `SuggestMeal#compareTo(...)`.
. `SuggestMeal` objects that meet the calorie requirement are sorted and an arrayList of `Meal` objects is returned, which contains the possible meals that the user can choose from.
. The `SuggestMealCommand#execute()` function then moves on to the next stage of data enquiry from user for meal selection and passes the input choice to `SuggestMealCommand#execute_stage_1` function, which then invokes the `AddCommand#execute` to add the selected meal to the application.


==== Design considerations

Problem 1: *How to determine most suitable meal for user*

* Solution 1: Assign total meal preference score of each meal in a list and provide meal suggestion based on the overall lowest cost of meal preferance score.

** Pros: Provides a way to compare various meal parameters together in which a total preference cost can be computed by by summing all the normalized parameter values.

** Cons: Requires a non-trivial way to normalize all the different parameter values. Example: Is a $1 cheaper meal worth 100 more calories to the user?

* Solution 2: Calculate the ranking of each parameter of each meal with the rest of the meals and provide meal suggestion based on the meal with the lowest ranking in as many of the parameters specified by the user.

** Pros: Simple to implement as it performs a static ranking of all the parameters of each meal.

** Cons: Has no way to objectify the difference across different parameter categories. Example: A very healthy meal that is very nutritious but costs $30 will likely be suggested to the user as it performs the best in all categories except price, giving it the lowest overall ranking although it costs 3 times as much as any other meal.

Problem 2: *How to prevent excessive repeated meal suggestions*

* Solution 1: Add another parameter to each meal that tracks the number of times the user has eaten that meal over a week and ensure the number does not cross a threshold maximum.

** Pros: New parameter created is easy to implement and is objectively able to limit the meal suggestions based on a threshold amount of times the food has been eaten.

** Cons: Arbitary threshold number may not work well for different users who have different preferences of how often they mind eating the same meal over a week.

* Solution 2: Provide a random meal suggestion based on the top few meals ranked by the preference score (within some tolerance to prevent low scoring meals from being accidentally suggested).

** Pros: Very easy to implement and allows for a (somewhat) guaranteed way to mix up the meal suggestions such that the meal is not consumed too often.

** Cons: Undeterministic meal suggestion that provides different meal suggestion given the same input parameters. There is still a small chance that the same meals can be suggested repeatedly.

=== Graph Command

The Graph Command provides a visualisation of the data specified by the user over a month so they are able to better adjust their choices of meals

The following section describes the implementation and design considerations involved in the Graph feature and how it outputs the graph onto command line.

==== Current implementation
The user can specify the month and year of the category of data they would like to view as a plotted graph. The implementation is as follows:

. User will specify the parameters of the data.
. After parsing through the user input, `Parser` will make sense of the input and return a `CGraphCommand` with the relevant `type`, `month` and `year`.
. `CGraphCommand` will then check the `type` and obtain the relevant data from the relevant objects.
.. For example, if the `type` is specified as `weight`, `CGraphCommand` will obtain the `weight` data from `User`.
. After obtaining the data in the form of a `HashMap`, `CGraphCommand` will run through the `HashMap` by checking for all dates in the specified `month` and `year`.
.. If a date is not found in the `keySet` of the `HashMap`, the data for that date will be assumed to be 0.
. The data found for each date is stored in an `ArrayList`.
. The biggest data found will also be stored as a variable called `highest`. This will be used for scaling of the graph.
. From this `ArrayList`, each data is scaled according to the `highest` variable stored and plotted accordingly in a 2-dimensional `Array`.
. This `Array` will then be passed to `GraphUi` for it to plot the graph on the commandline.

==== Design considerations

Problem 1: *How to output the x axis for days appropriately so that the double digits do not mess up the command line scaling*

* Solution 1: Print the 1st digit in the first line, and the 2nd digit on the second line.

** Pros: All day values are able to be displayed using one character space.

** Cons: It takes up an additional line of space

Problem 2: *Preventing data from being too large and taking too much space*

* Solution 1: Find the highest value of the data, and scale all of the values according to the highest value.

** Pros: Data can output on the graph without exceeding limits. Users are able to see the fluctuation of the values.

** Cons: Users are unable to check the exact value of each points.

* Solution 1: Output the data according to the number of space.

** Pros: Users are able to check the exact value of each points.

** Cons: If the data is too big, it may go out of the intended graph range and the desired output may be skewed. This may prevent users from being able to accurately see their progress.

.CGraph command sequence diagram
image::cgraphcommand.png[width="800"]

== Documentation
=== Introduction

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Docs-SiteWideDocSettings]]
=== Site-wide Documentation Settings

The link:{repoURL}/build.gradle[`build.gradle`] file specifies some project-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how all documentation files within this project are rendered.

[TIP]
Attributes left unset in the `build.gradle` file will use their *default value*, if any.

[cols="1,2a,1", options="header"]
.List of site-wide attributes
|===
|Attribute name |Description |Default value

|`site-name`
|The name of the website.
If set, the name will be displayed near the top of the page.
|_not set_

|`site-githuburl`
|URL to the site's repository on https://github.com[GitHub].
Setting this will add a "View on GitHub" link in the navigation bar.
|_not set_

|`site-seedu`
|Define this attribute if the project is an official SE-EDU project.
This will render the SE-EDU navigation bar at the top of the page, and add some SE-EDU-specific navigation items.
|_not set_

|===

[[Docs-PerFileDocSettings]]
=== Per-file Documentation Settings

Each `.adoc` file may also specify some file-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how the file is rendered.

Asciidoctor's https://asciidoctor.org/docs/user-manual/#builtin-attributes[built-in attributes] may be specified and used as well.

[TIP]
Attributes left unset in `.adoc` files will use their *default value*, if any.

[cols="1,2a,1", options="header"]
.List of per-file attributes, excluding Asciidoctor's built-in attributes
|===
|Attribute name |Description |Default value
|`site-section`
|Site section that the document belongs to.
This will cause the associated item in the navigation bar to be highlighted.
One of: `UserGuide`, `DeveloperGuide`, `AboutUs`, `ContactUs`
|_not set_
|`no-site-header`
|Set this attribute to remove the site navigation bar.
|_not set_

|===

== Testing
=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


== Dev Ops
=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects. See <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews

When a pull request has changes to asciidoc files, you can use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of those asciidoc files will look like when the pull request is merged. See <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the https://github.com/FasterXML/jackson[Jackson library] for JSON parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives:

[loweralpha]
. Include those libraries in the repo (this bloats the repo size)
. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Value Propositions

**Target User Profile:**

NUS Students who are trying to plan their meals for a specific diet goal such as losing weight, maintaining weight, or building muscle.

**Propositions:**

* DIYeats makes it radically easy to maintain and keep track of your daily nutritional intake in a single Command Line Interface (CLI) and Graphical User Interface (GUI).
* DIYeats lets you set your own weight goal based on your height and your activity level.
* DIYeats gives you liberty to follow any eating style and create your own customized meals.
* DIYeats allows you to plan ahead and reduce the food waste due to overshopping groceries.
* DIYeats plans on integrating all food items in NUS into its database, which can allow it to suggest meals in NUS that would allow the user to meet their nutritional targets.
* DIYeats elegantly displays the progress of your diet to help you motivate yourself and others.
* DIYeats saves your effort and efficiently suggest and plan the meals for you.

[appendix]
== User Stories
[width="80%",cols="20%,<20%,<30%,<30%",options="header",]
|=======================================================================
|Priority |As a... |I want to... |So that I can...
|HIGH |NUS student |be able to plan my meals ahead |I know beforehand what to eat the next day, amidst my busy schedule
|HIGH |NUS student |list of dishes and each nutritional value in NUS Canteens| I can make an informed decisions to pick healthier meal
|HIGH |NUS sportsman |track the amount of nutrition I need to take in a day |I can plan my meal and avoid overeating/undereating
|HIGH |someone looking to lose weight |track the daily calories intake based on my target body weight |I am able to regulate the amount of food I eat in the day
|HIGH |unregistered user |create a customized profile of myself (e.g. weight and height)| I don’t have to input the profile every time I open the application
|HIGH |vegetarian |create a meal plan that does not require meat or dairy product |I could eat healthy with my vegetarian preference
|MEDIUM |someone who is not great at typing |an autocorrect feature |I don’t input incorrect dish names
|MEDIUM |forgetful user |remind myself of the available commands in an application |I don’t have to waste my time rustling through user guide
|MEDIUM |forgetful user |have a way to remind me how much nutrition I have to take to reach the target nutrient intake |I could plan my subsequent meal accordingly
|MEDIUM |careless user |be able to revert changes done previously |I don’t have to manually revert the changes
|MEDIUM |efficient user |clear and add multiple meals at once |I don’t have to input the same command multiple times
|MEDIUM |efficient user |add a recurring meal (every week, biweekly) |I don’t have same command multiple times
|MEDIUM |cautious user |have a way to detect when a planned meal in the future is higher than the average required intake |I won’t accidentally exceed the quota
|LOW |someone who appreciates keyboard shortcuts |have a way to recognize short forms of keywords used in the app |I can work faster
|LOW |someone who likes to motivate people |have a way to print my progress in the past month |I can motivate other people to live healthily
|LOW |someone likes different themes |have a way to change the color scheme of the application |it is easier to the eyes.
|LOW |someone likes different themes |have different colors for different tasks |I am able to distinguish between them easily.
|=======================================================================

[appendix]
== Use Cases
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC01 - Customizing User Profile

Main Success Scenario:

1. DIYeats detects that user profile has not been specified and prompts for information regarding height, weight, and lifestyle

2. Student enters the required information based on his profile

3. DIYeats indicates that user profile has been recorded.

Use case ends.

Extensions:

2.1: DIYeats detects an error in the entered data.

2.1.1: DIYeats requests for the correct data.

2.1.2: Student enters new data.

Steps 2.1.1 - 2.1.2 are repeated until the data entered are correct.

Use case resumes from step 3.

3.1: Student requests to change the user profile.

Use case resumes from step 1.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC02 - Planning Meals

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile)

Main Success Scenario:

1. Student chooses the food he/she is planning to eat and corresponds the food to the respective meal.

2. DIYeats indicates the meal has been recorded.

3. Steps 1-2 are repeated until Student has inputted all the meals intended

Use case ends.

Extensions:

1.1: Student wants to record a meal that happened before the current day.

1.1.1: Student specifies the past date the meal occurred.

Use case resumes from step 2.

1.2: Student wants to change the nutritional value of the meal

1.2.1:  Student specifies the nutritional value of the meal.

Use case resumes from step 2.

1.3: DIYeats detects that the nutritional value exceeds the average required intake.(which is set up in UC07- Set Goal Intake)

1.3.1: DIYeats warn the Student of the anomaly and ask for confirmation/modify request.

1.3.2: Student modifies the input data or confirm the input.

Use case resumes from step 2.

1.4: DIYeats detects the wrong input from Student.

1.4.1: DIYeats prompts Student to re-enter the command.

1.4.2: Student enters the command.

Steps 1.4.1 - 1.4.2 are repeated until the command entered are correct.

Use case resumes from step 2.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC03 - List Meals

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals are entered. (Refer to UC02 - Planning Meals).

Main Success Scenario:

1. NUS Student requests to display meal and the nutritional intake for today.

2. DIYeats display the recorded meals taken / will be taken today and its nutritional value.

Use Case Ends.

Extensions:

1.1: NUS Student wants to specify a date other than today

1.1.1: DIYeats display the recorded meals and intake on that date

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC04 - Remind Meals

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals are entered. (Refer to UC02 - Planning Meals).

Main Success Scenario:

1. User requests to be reminded on how much nutrition the student intake to reach the target nutrient intake for the month.

2. DIYeats display the information.

Use Case Ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC05 - Find meal(s)

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals are entered. (Refer to UC02 - Planning Meals).

Main Success Scenario:

1. Student requests to find a specific food student had in the past

2. DIYeats displays the queried food and its description.

Use case ends.

Extensions:

1.1: DIYeats does not recognize the food requested

1.1.1: DIYeats displays the error message.

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC06 - Delete meal

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals can be found. (Refer to UC05 - Find meal(s)).

Main Success Scenario:

. Student requests to delete a specific food student had in the past.
. DIYeats displays the queried food and its description and the confirmation message.

Use case ends.

Extensions:

1.1: DIYeats does not recognize the food requested.

1.1.1: DIYeats displays the error message.

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC07 - Set Goal Intake

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile).

Main Success Scenario:

1. Student requests for nutritional goals to be met at the end of a time frame (end of month)

2. DIYeats displays the nutritional goals that have been inputted and a confirmation goals.

3. Use case ends.

Extensions:

1.1: DIYeats detects an error in the entered data.

1.1.1: DIYeats requests for the correct data.

1.1.2: Student enters new data.

Steps 1.1.1 - 1.1.2 are repeated until the data entered are correct.

Use case resumes from step 2.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC08 - Meal Recommendation

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Some meals already eaten. ( Refer to UC02 - Planning Meals). Goal intake set. (Refer to UC07 - Set Goal Intake).

Main Success Scenario:

1. Student unsure of what food to eat for the next meal and asks DIYeats to recommend a food that fits within the goal intake set.

2. DIYeats displays a small list of nutritional food that fit within the goal intake plan set by the student.

3. Student can choose to select food from the list generated in step 2 or proceed to key in any other food as per normal.

Use case ends.

Extensions:

1.1: DIYeats has a customizable recommendation system.

1.1.1: Student filters recommended list by meals by meal type          (only recommend food which was eaten for lunch and not dinner).

Step 1.1.1 is repeated until the student is satisfied with the constraints for food recommendation.

Use case resumes from step 2.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC09 - Generate Statistics

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Some meals already eaten. ( Refer to UC02 - Planning Meals). Goal intake set. (Refer to UC07 - Set Goal Intake).

Main Success Scenario:

1. Student requests for the statistics of the amount of nutrients that have been eaten in a specific time frame.

2. DIYeats displays the statistics, accompanied by the goal intake that is set by the student.

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC10 - Generate Graphs

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Some meals already eaten. ( Refer to UC02 - Planning Meals). Goal intake set. (Refer to UC07 - Set Goal Intake).

Main Success Scenario:

1. Student requests for the graph of the amount of nutrients that have been eaten in a specific time frame.

2. DIYeats displays the graph, accompanied by the goal intake that is set by the student.

Use case ends.
|=======================================================================


[appendix]
== Non-functional Requirements

* The data (user profile, meal plans, and schedule) should be persistent even if the user terminates the applications.
* The user interface should be intuitive enough to be used by a new user who has never been introduced to the program.
* The system must respond fast enough and feels snappy.
* The program must be able to be used in different platforms/operating systems (Linux, Windows, and Macintosh).
* The source code must be documented properly and adhere to the coding standards to be easily read by new developers that intend to contribute to the projects.
* The application must not violate intellectual property rights or export of restricted technologies. The third party libraries used must be approved and open source in nature.

[appendix]
== Glossary

* *Current date*: Date obtained from the system date in user’s local machine.
* *Meal*: Only includes breakfast, lunch, and dinner.
* *Session*: A period of time where the user interacts with the application. The session begins when the user launches the application, and ends when the user terminates the application.